# Домашнее задание
# Триггеры, поддержка заполнения витрин
### Цель:
- Создать триггер для поддержки витрины в актуальном состоянии.

### Описание/Пошаговая инструкция выполнения домашнего задания:
- Скрипт и развернутое описание задачи – в ЛК (файл hw_triggers.sql) или по ссылке: https://disk.yandex.ru/d/l70AvknAepIJXQ

- В БД создана структура, описывающая товары (таблица goods) и продажи (таблица sales).

- Есть запрос для генерации отчета – сумма продаж по каждому товару.

- БД была денормализована, создана таблица (витрина), структура которой повторяет структуру отчета.

- Создать триггер на таблице продаж, для поддержки данных в витрине в актуальном состоянии (вычисляющий при каждой продаже сумму и записывающий её в витрину)

- Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE
___________________________________
Задание со звездочкой*
Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
Подсказка: В реальной жизни возможны изменения цен.

### Критерии оценки:

- *10 баллов за стандартное решение*
- *плюс 5 баллов за задание с **
- *плюс 2 балла за красивое решение*
- *минус 2 балла за рабочее решение, недостатки, указанные преподавателем не устранены*

# Решение:
### Используемые инструменты:
- Docker, источник - [www.docker.com](https://www.docker.com/ "www.docker.com")
- Образ *postgres:15.6-alpine3.19*, источник -  [hub.docker.com](https://hub.docker.com/)
- Desktop application DBeaver, источник -  [dbeaver](https://dbeaver.io/) ![](https://dbeaver.io/wp-content/uploads/2015/09/beaver-head.png)


## Ход выполнения:
1. Создаем схему pract_functions и всю необходимую инфраструктуру с помщью файла hw_triggers.sql
2. Реализацию наполнения таблицы good_sum_mart через триггер решено сделать путем доавления  в нее дельт по измененным обновленным или удаленным товарам, во избежание накопления в базе мертвых строк. Что бы можно было смотреть историю добавления дельт в таблицу good_sum_mart при ее создании было добавлено поле:
```sql
time_add_row timestamp with time zone DEFAULT now()
```
3. Для просмотра нового отчета было создано представление:
```sql
CREATE OR REPLACE VIEW pract_functions.v_good_sum_mart
AS
SELECT
    gsm.good_name
    ,sum(gsm.sum_sale) AS sum_sale
FROM pract_functions.good_sum_mart gsm
GROUP BY gsm.good_name
;
```
4. Для реализации наполнения таблицы good_sum_mart через триггер созданы соответствующие триггеры и триггерная функция (см. файл Script.sql)

5. Я бы не сказал, что схема (витрина+триггер) предпочтительнее отчета. Все зависит от поставленной задачи. Понятно, что при обновлении цены за единицу продукции отчет будет показывать всегда сумму продаж по актуальной цене. С помощью триггера мы это избегаем и показываем сумму продаж, на которую изменеие цены за предыдущие периоды не влияеят. Но может оказаться, что нужен именно первый вариант.
	С быстродействием тоже спорно. Триггеры всегда увеличивают нагрузку на базу, создают дополнительные транзакции, триггерные функции тяжелее отлаживаются, в базе появляются новые объекты и данные. Все это может привести к размножению мертвых записей и распуханию базы как следсвтие. В моем случае, во избежания мертвых записей пришлось идти по пути добавления дэльт. Скорее всего при увеличении объема таблицы придется проводить работы по оптимизации: создадвать дополнительные индексы, возможно применять партиционирование и т.п. и т.д.



